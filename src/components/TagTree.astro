---
/**
 * タグツリービューコンポーネント
 * 階層構造を持つタグを視覚的に表示
 */

import type { TagHierarchy } from '../types/tag';
import TagBadge from './TagBadge.astro';

interface Props {
  /** タグ階層データ */
  hierarchy: TagHierarchy;
  /** ベースURL（デフォルト: /tags/） */
  baseUrl?: string;
  /** 使用回数を表示するか */
  showCount?: boolean;
  /** 初期状態で展開するか */
  expandAll?: boolean;
  /** 最大表示レベル */
  maxLevel?: number;
  /** 初期表示レベル（デフォルト: 1 - ルートと第1レベルを表示） */
  initialDisplayLevel?: number;
  /** 追加のCSSクラス */
  className?: string;
}

const { 
  hierarchy, 
  baseUrl = '/tags/',
  showCount = true,
  expandAll = false,
  maxLevel = 5,
  initialDisplayLevel = 1,
  className = ''
} = Astro.props;

// 階層構造をフラット化して表示用データを作成
function flattenHierarchy(
  node: TagHierarchy, 
  level = 0,
  parentPath = ''
): Array<{
  tag: any;
  level: number;
  hasChildren: boolean;
  path: string;
  parentPath: string;
  isInitiallyVisible: boolean;
}> {
  const result: any[] = [];
  
  if (level > maxLevel) return result;
  
  Object.entries(node).forEach(([tagName, { tag, children }]) => {
    // tagNameはすでに完全なタグパスを表している
    const currentPath = tagName;
    const hasChildren = children && Object.keys(children).length > 0;
    
    // 親パスを正しく計算（最後のスラッシュ以前の部分）
    const actualParentPath = tagName.includes('/') 
      ? tagName.substring(0, tagName.lastIndexOf('/')) 
      : '';
    
    // 初期表示レベル以下は表示、それより深い階層は非表示
    const isInitiallyVisible = level <= initialDisplayLevel;
    
    result.push({
      tag,
      level,
      hasChildren,
      path: currentPath,
      parentPath: actualParentPath,
      isInitiallyVisible
    });
    
    // 子階層を再帰的に処理
    if (hasChildren && level < maxLevel) {
      result.push(...flattenHierarchy(children, level + 1, ''));
    }
  });
  
  return result;
}

const flatHierarchy = flattenHierarchy(hierarchy);

// TreeのCSVクラスを構築
const treeClasses = [
  'tag-tree',
  className
].filter(Boolean).join(' ');
---

<div class={treeClasses} role="tree" aria-label="タグ階層ツリー">
  {flatHierarchy.map((item, index) => {
    const nodeId = `tree-node-${item.tag.slug}`;
    const indentLevel = item.level;
    const isVisible = item.isInitiallyVisible;
    const hasChildren = item.hasChildren;
    // デフォルトで全て折りたたみ
    const isExpanded = expandAll;
    
    return (
      <div 
        class={`tree-node tree-level-${indentLevel} ${hasChildren ? 'has-children' : 'leaf-node'} ${!isVisible ? 'initially-hidden' : ''}`}
        role="treeitem"
        aria-level={indentLevel + 1}
        aria-expanded={hasChildren ? isExpanded : undefined}
        id={nodeId}
        data-tag-path={item.path}
        data-level={indentLevel}
        data-has-children={hasChildren}
        style={!isVisible ? 'display: none;' : ''}
      >
        <div class="tree-node-content">
          <!-- インデント用のスペーサー -->
          <div class="tree-indent" style={`width: ${indentLevel * 1.5}rem`}>
            {Array.from({ length: indentLevel }, (_, i) => (
              <div class="indent-guide" key={i}></div>
            ))}
          </div>
          
          <!-- 展開/折りたたみボタン -->
          {item.hasChildren && (
            <button 
              class="tree-toggle"
              aria-label={`${item.tag.name}の子タグを表示/非表示`}
              data-toggle-target={nodeId}
            >
              <svg 
                class="toggle-icon" 
                width="12" 
                height="12" 
                viewBox="0 0 12 12"
                aria-hidden="true"
              >
                <path 
                  d="M4.5 3L7.5 6L4.5 9" 
                  stroke="currentColor" 
                  stroke-width="1.5" 
                  fill="none"
                  stroke-linecap="round" 
                  stroke-linejoin="round"
                />
              </svg>
            </button>
          )}
          
          <!-- フォルダ/ファイルアイコン -->
          <div class="tree-icon" aria-hidden="true">
            {item.hasChildren ? (
              <!-- フォルダアイコン -->
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M1.75 2.5a.75.75 0 0 0-.75.75v9.5c0 .414.336.75.75.75h12.5a.75.75 0 0 0 .75-.75v-7.5a.75.75 0 0 0-.75-.75H8.56L7.06 3.25a.75.75 0 0 0-.53-.22H1.75z"/>
              </svg>
            ) : (
              <!-- ファイルアイコン -->
              <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor">
                <path d="M2 1.75C2 .784 2.784 0 3.75 0h6.586c.464 0 .909.184 1.237.513l2.914 2.914c.329.328.513.773.513 1.237v9.586A1.75 1.75 0 0 1 13.25 16h-9.5A1.75 1.75 0 0 1 2 14.25Zm1.75-.25a.25.25 0 0 0-.25.25v12.5c0 .138.112.25.25.25h9.5a.25.25 0 0 0 .25-.25V6h-2.75A1.75 1.75 0 0 1 9 4.25V1.5Zm6.75.062V4.25c0 .138.112.25.25.25h2.688l-.011-.013-2.914-2.914-.013-.011Z"/>
              </svg>
            )}
          </div>
          
          <!-- タグバッジ -->
          <div class="tree-tag">
            <TagBadge
              tag={item.tag.name}
              href={`${baseUrl}${item.tag.name.toLowerCase()}`}
              count={showCount ? item.tag.count : undefined}
              className="tree-tag-badge"
            />
          </div>
        </div>
      </div>
    );
  })}
  
  {flatHierarchy.length === 0 && (
    <div class="tree-empty" role="treeitem">
      <div class="tree-empty-message">
        階層タグがありません
      </div>
    </div>
  )}
</div>

<style>
  .tag-tree {
    font-family: var(--font-mono, 'Monaco', 'Consolas', monospace);
    font-size: 0.9rem;
    line-height: 1.4;
    background: var(--tree-bg, oklch(100% 0 0));
    border: 1px solid var(--tree-border, oklch(92% 0.010 280));
    border-radius: 8px;
    padding: 1rem;
    margin: 1rem 0;
  }
  
  .tree-node {
    display: block;
    margin: 0;
    position: relative;
  }
  
  .tree-node.has-children {
    margin-bottom: 0.25rem;
  }
  
  .tree-node.leaf-node {
    margin-bottom: 0.125rem;
  }
  
  .tree-node-content {
    display: flex;
    align-items: center;
    padding: 0.25rem 0;
    border-radius: 4px;
    transition: background-color 0.15s ease;
    min-height: 2rem;
  }
  
  .tree-node-content:hover {
    background-color: var(--tree-hover-bg, oklch(96% 0.008 280 / 0.5));
  }
  
  .tree-indent {
    display: flex;
    flex-shrink: 0;
    position: relative;
  }
  
  .indent-guide {
    width: 1.5rem;
    height: 100%;
    position: relative;
  }
  
  .indent-guide::before {
    content: '';
    position: absolute;
    left: 0.75rem;
    top: 0;
    bottom: 0;
    width: 1px;
    background-color: var(--tree-guide-color, oklch(92% 0.010 280));
  }
  
  .tree-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    border: none;
    background: none;
    color: var(--tree-toggle-color, oklch(55% 0.015 280));
    cursor: pointer;
    border-radius: 3px;
    transition: all 0.15s ease;
    flex-shrink: 0;
    margin-right: 0.25rem;
  }

  .tree-toggle:hover {
    background-color: var(--tree-toggle-hover-bg, oklch(96% 0.008 280 / 0.8));
    color: var(--tree-toggle-hover-color, oklch(35% 0.015 280));
  }
  
  .tree-toggle:focus {
    outline: 2px solid var(--tag-focus-color, oklch(55% 0.24 293));
    outline-offset: var(--tag-focus-offset, 2px);
  }
  
  .toggle-icon {
    transition: transform 0.15s ease;
  }
  
  .tree-node[aria-expanded="true"] .toggle-icon {
    transform: rotate(90deg);
  }
  
  .tree-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 1.5rem;
    height: 1.5rem;
    color: var(--color-text-secondary, oklch(55% 0.015 280));
    flex-shrink: 0;
    margin-right: 0.5rem;
  }

  .tree-node.has-children .tree-icon {
    color: var(--color-accent, oklch(55% 0.24 293));
  }
  
  .tree-tag {
    flex: 1;
    min-width: 0;
  }
  
  .tree-tag :global(.tree-tag-badge) {
    font-size: 0.85rem;
    padding: 0.15rem 0.5rem;
    margin: 0;
  }
  
  /* 階層レベル別のスタイリング */
  .tree-level-0 .tree-node-content {
    font-weight: 600;
  }
  
  .tree-level-1 .tree-tag :global(.tree-tag-badge) {
    font-size: 0.8rem;
  }
  
  .tree-level-2 .tree-tag :global(.tree-tag-badge) {
    font-size: 0.75rem;
    opacity: 0.9;
  }
  
  .tree-level-3 .tree-tag :global(.tree-tag-badge) {
    font-size: 0.7rem;
    opacity: 0.8;
  }
  
  .tree-level-4 .tree-tag :global(.tree-tag-badge) {
    font-size: 0.65rem;
    opacity: 0.7;
  }
  
  .tree-empty {
    text-align: center;
    padding: 2rem 1rem;
    color: var(--color-text-secondary, oklch(55% 0.015 280));
    font-style: italic;
  }
  
  .tree-empty-message {
    font-size: 0.9rem;
  }
  
  /* 折りたたみ状態の制御はJavaScriptで行う */
  
  /* 初期非表示状態 */
  .tree-node.initially-hidden {
    display: none;
  }
  
  /* ダークモード対応 - CSS変数を使用（デザイントークンに統一） */
  html.dark .tag-tree {
    background: var(--tree-bg);
    border-color: var(--tree-border);
  }

  html.dark .tree-node-content:hover {
    background-color: var(--tree-hover-bg);
  }

  html.dark .tree-toggle:hover {
    background-color: var(--tree-toggle-hover-bg);
  }

  html.dark .indent-guide::before {
    background-color: var(--tree-guide-color);
  }
  
  /* アニメーション */
  @media (prefers-reduced-motion: no-preference) {
    .tree-node {
      animation: fadeIn 0.2s ease-in-out;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(-4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
  }
  
  /* レスポンシブ対応 */
  @media (max-width: 640px) {
    .tag-tree {
      font-size: 0.8rem;
      padding: 0.75rem;
    }
    
    .tree-toggle,
    .tree-icon {
      width: 1.25rem;
      height: 1.25rem;
    }
    
    .tree-indent {
      margin-right: 0.125rem;
    }
    
    .indent-guide {
      width: 1.25rem;
    }
    
    .tree-tag :global(.tree-tag-badge) {
      font-size: 0.75rem !important;
      padding: 0.1rem 0.4rem;
    }
  }
</style>

<script>
  // タグツリーの展開/折りたたみ機能
  // astro:page-load は初回ロードとView Transitions後の両方で発火する
  function initTagTree() {
    const trees = document.querySelectorAll('.tag-tree');

    // 初期状態で折りたたみ状態を設定
    trees.forEach(tree => {
      // 既に初期化済みの場合はスキップ
      if (tree.dataset.initialized === 'true') return;
      tree.dataset.initialized = 'true';

      const nodes = tree.querySelectorAll('.tree-node');
      nodes.forEach(node => {
        const level = parseInt(node.dataset.level || '0');
        const hasChildren = node.dataset.hasChildren === 'true';

        if (hasChildren) {
          // デフォルトで全て折りたたみ
          const isExpanded = false;
          node.setAttribute('aria-expanded', isExpanded.toString());

          if (!isExpanded) {
            // 折りたたみ状態の場合、子タグを非表示
            hideChildrenNodes(node);
          }
        }
      });

      tree.addEventListener('click', (event) => {
        const button = event.target.closest('.tree-toggle');
        if (!button) return;

        const nodeId = button.dataset.toggleTarget;
        const node = document.getElementById(nodeId);
        if (!node) return;

        const isExpanded = node.getAttribute('aria-expanded') === 'true';
        const newExpanded = !isExpanded;

        // 展開状態を更新
        node.setAttribute('aria-expanded', newExpanded.toString());

        if (newExpanded) {
          // 展開：直接の子タグのみ表示
          showDirectChildren(node);
        } else {
          // 折りたたみ：全ての子孫タグを非表示
          hideChildrenNodes(node);
        }

        // アクセシビリティ用のアナウンス
        const tagName = node.querySelector('.tree-tag-badge')?.textContent?.trim();
        const action = newExpanded ? '展開' : '折りたたみ';

        // スクリーンリーダー用の一時的な通知
        const announcement = document.createElement('div');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.style.position = 'absolute';
        announcement.style.left = '-10000px';
        announcement.textContent = `${tagName}の子タグを${action}しました`;

        document.body.appendChild(announcement);
        setTimeout(() => {
          document.body.removeChild(announcement);
        }, 1000);
      });

      // キーボードナビゲーション
      tree.addEventListener('keydown', (event) => {
        const currentNode = event.target.closest('.tree-node');
        if (!currentNode) return;

        switch (event.key) {
          case 'ArrowRight':
            event.preventDefault();
            if (currentNode.dataset.hasChildren === 'true') {
              const button = currentNode.querySelector('.tree-toggle');
              if (button && currentNode.getAttribute('aria-expanded') !== 'true') {
                button.click();
              }
            }
            break;

          case 'ArrowLeft':
            event.preventDefault();
            if (currentNode.getAttribute('aria-expanded') === 'true') {
              const button = currentNode.querySelector('.tree-toggle');
              if (button) {
                button.click();
              }
            }
            break;

          case 'ArrowDown':
            event.preventDefault();
            const nextVisibleNode = getNextVisibleNode(currentNode);
            if (nextVisibleNode) {
              nextVisibleNode.focus();
            }
            break;

          case 'ArrowUp':
            event.preventDefault();
            const prevVisibleNode = getPrevVisibleNode(currentNode);
            if (prevVisibleNode) {
              prevVisibleNode.focus();
            }
            break;
        }
      });
    });

    // 直接の子タグのみ表示する関数
    function showDirectChildren(parentNode) {
      const parentLevel = parseInt(parentNode.dataset.level || '0');
      const parentPath = parentNode.dataset.tagPath;
      const targetLevel = parentLevel + 1;

      let nextNode = parentNode.nextElementSibling;
      while (nextNode && nextNode.classList.contains('tree-node')) {
        const nextLevel = parseInt(nextNode.dataset.level || '0');
        const nextPath = nextNode.dataset.tagPath;

        // 同レベルまたは上のレベルに到達したら終了
        if (nextLevel <= parentLevel) {
          break;
        }

        // 直接の子かどうかチェック
        if (nextLevel === targetLevel && nextPath && nextPath.startsWith(parentPath + '/')) {
          // 親のパス + "/" + 子の名前 の形式かどうかチェック
          const childPart = nextPath.substring(parentPath.length + 1);
          if (!childPart.includes('/')) {
            // 直接の子（中間にスラッシュがない）
            nextNode.style.display = 'block';
            nextNode.classList.remove('initially-hidden');
          }
        }

        nextNode = nextNode.nextElementSibling;
      }
    }

    // 子孫タグを全て非表示する関数
    function hideChildrenNodes(parentNode) {
      const parentLevel = parseInt(parentNode.dataset.level || '0');
      const parentPath = parentNode.dataset.tagPath;

      let nextNode = parentNode.nextElementSibling;
      while (nextNode && nextNode.classList.contains('tree-node')) {
        const nextLevel = parseInt(nextNode.dataset.level || '0');
        const nextPath = nextNode.dataset.tagPath;

        // 同レベルまたは上のレベルに到達したら終了
        if (nextLevel <= parentLevel) {
          break;
        }

        // このノードの子孫かどうかチェック
        if (nextPath && nextPath.startsWith(parentPath + '/')) {
          nextNode.style.display = 'none';
          nextNode.classList.add('initially-hidden');
          // 子ノードも折りたたみ状態に
          if (nextNode.dataset.hasChildren === 'true') {
            nextNode.setAttribute('aria-expanded', 'false');
          }
        }

        nextNode = nextNode.nextElementSibling;
      }
    }

    function getNextVisibleNode(currentNode) {
      let next = currentNode.nextElementSibling;
      while (next && next.classList.contains('tree-node')) {
        if (next.style.display !== 'none' && !next.classList.contains('initially-hidden')) {
          return next;
        }
        next = next.nextElementSibling;
      }
      return null;
    }

    function getPrevVisibleNode(currentNode) {
      let prev = currentNode.previousElementSibling;
      while (prev && prev.classList.contains('tree-node')) {
        if (prev.style.display !== 'none' && !prev.classList.contains('initially-hidden')) {
          return prev;
        }
        prev = prev.previousElementSibling;
      }
      return null;
    }
  }

  // 初回ロード時
  document.addEventListener('DOMContentLoaded', initTagTree);

  // View Transitions後（astro:page-loadは初回とナビゲーション両方で発火）
  document.addEventListener('astro:page-load', initTagTree);
</script>